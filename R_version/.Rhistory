constructRateMatrix <- function(num_genes,
alpha, beta,
lambda_i, mu_i,
lambda_a, mu_a,
lambda_ai = 0, lambda_ia = 0,
denovo_i = 0, denovo_a = 0) {
# get the number of states
num_states <- computeNumStates(num_genes)
# get the state labels
state_labels <- getStateLabels(num_genes)
# make a blank matrix
rate_matrix <- matrix(0, num_states, num_states, dimnames=list(state_labels,state_labels))
# fill in the denovo origination rates
rate_matrix[1,3] <- denovo_i
rate_matrix[1,4] <- denovo_a
# now fill in the rest of the matrix
for(fam_size in 1:num_genes) {
for(num_active in 1:fam_size) {
recover()
i = 1 + 0.5 * fam_size * (fam_size + 1) + num_active
#duplication rate of inactive genes
if ( i + fam_size + 2 < num_states ) {
rate_matrix[i,i+fam_size+1] = num_active * lambda_ai + (fam_size - num_active) * lambda_i
} else {
rate_matrix[i,num_states] = num_active * lambda_ai + (fam_size - num_active) * lambda_i
}
#duplication rate of active genes
if ( i + fam_size + 3 <= num_states ) {
rate_matrix[i,i+fam_size+2] = (fam_size - num_active) * lambda_ia + num_active * lambda_a
} else {
rate_matrix[i,num_states] = rate_matrix[i,num_states] + (fam_size - num_active) * lambda_ia + num_active * lambda_a
}
#deletion and inactivation rates of active genes
if ( num_active > 0 ) {
rate_matrix[i,i-fam_size-1] = mu_a * num_active;
rate_matrix[i,i-1] = beta * num_active;
}
#deletion and activation rates of inactive genes
if ( fam_size > num_active ) {
rate_matrix[i,i-fam_size] = mu_i * (fam_size - num_active);
rate_matrix[i,i+1] = alpha * (fam_size - num_active);
}
}
}
# set rowsums to 0
for(i in 1:nrow(rate_matrix)) {
rate_matrix[i,i] <- -sum(rate_matrix[i,])
}
return(rate_matrix)
}
constructRateMatrix(2, alpha, beta, lambda_i, mu_i, lambda_a, mu_a, denovo_i = denovo_i, denovo_a = denovo_a)
i
i = 1 + 0.5 * fam_size * (fam_size + 1) + num_active
i
num_active
fam_size
num_states
0.5 * fam_size * (fam_size + 1)
constructRateMatrix <- function(num_genes,
alpha, beta,
lambda_i, mu_i,
lambda_a, mu_a,
lambda_ai = 0, lambda_ia = 0,
denovo_i = 0, denovo_a = 0, recover_x = FALSE) {
# get the number of states
num_states <- computeNumStates(num_genes)
# get the state labels
state_labels <- getStateLabels(num_genes)
# make a blank matrix
rate_matrix <- matrix(0, num_states, num_states, dimnames=list(state_labels,state_labels))
# fill in the denovo origination rates
rate_matrix[1,3] <- denovo_i
rate_matrix[1,4] <- denovo_a
# now fill in the rest of the matrix
for(fam_size in 1:num_genes) {
for(num_active in 1:fam_size) {
if(recover_x) recover()
i = 1 + 0.5 * fam_size * (fam_size + 1) + num_active
#duplication rate of inactive genes
if ( i + fam_size + 2 < num_states ) {
rate_matrix[i,i+fam_size+1] = num_active * lambda_ai + (fam_size - num_active) * lambda_i
} else {
rate_matrix[i,num_states] = num_active * lambda_ai + (fam_size - num_active) * lambda_i
}
#duplication rate of active genes
if ( i + fam_size + 3 <= num_states ) {
rate_matrix[i,i+fam_size+2] = (fam_size - num_active) * lambda_ia + num_active * lambda_a
} else {
rate_matrix[i,num_states] = rate_matrix[i,num_states] + (fam_size - num_active) * lambda_ia + num_active * lambda_a
}
#deletion and inactivation rates of active genes
if ( num_active > 0 ) {
rate_matrix[i,i-fam_size-1] = mu_a * num_active;
rate_matrix[i,i-1] = beta * num_active;
}
#deletion and activation rates of inactive genes
if ( fam_size > num_active ) {
rate_matrix[i,i-fam_size] = mu_i * (fam_size - num_active);
rate_matrix[i,i+1] = alpha * (fam_size - num_active);
}
print(rate_matrix)
}
}
# set rowsums to 0
for(i in 1:nrow(rate_matrix)) {
rate_matrix[i,i] <- -sum(rate_matrix[i,])
}
return(rate_matrix)
}
constructRateMatrix(2, alpha, beta, lambda_i, mu_i, lambda_a, mu_a, denovo_i = denovo_i, denovo_a = denovo_a)
constructRateMatrix <- function(num_genes,
alpha, beta,
lambda_i, mu_i,
lambda_a, mu_a,
lambda_ai = 0, lambda_ia = 0,
denovo_i = 0, denovo_a = 0, recover_x = FALSE) {
# get the number of states
num_states <- computeNumStates(num_genes)
# get the state labels
state_labels <- getStateLabels(num_genes)
# make a blank matrix
rate_matrix <- matrix(0, num_states, num_states, dimnames=list(state_labels,state_labels))
# fill in the denovo origination rates
rate_matrix[1,3] <- denovo_i
rate_matrix[1,4] <- denovo_a
# now fill in the rest of the matrix
for(fam_size in 1:num_genes) {
for(num_active in 1:fam_size) {
if(recover_x) recover()
i = 1 + 0.5 * fam_size * (fam_size + 1) + num_active
#duplication rate of inactive genes
if ( i + fam_size + 2 < num_states ) {
rate_matrix[i,i+fam_size+2] = num_active * lambda_ai + (fam_size - num_active) * lambda_i
} else {
rate_matrix[i,num_states+1] = num_active * lambda_ai + (fam_size - num_active) * lambda_i
}
#duplication rate of active genes
if ( i + fam_size + 3 <= num_states ) {
rate_matrix[i,i+fam_size+3] = (fam_size - num_active) * lambda_ia + num_active * lambda_a
} else {
rate_matrix[i,num_states+1] = rate_matrix[i,num_states] + (fam_size - num_active) * lambda_ia + num_active * lambda_a
}
#deletion and inactivation rates of active genes
if ( num_active > 0 ) {
rate_matrix[i,i-fam_size] = mu_a * num_active;
rate_matrix[i,i] = beta * num_active;
}
#deletion and activation rates of inactive genes
if ( fam_size > num_active ) {
rate_matrix[i,i-fam_size+1] = mu_i * (fam_size - num_active);
rate_matrix[i,i+2] = alpha * (fam_size - num_active);
}
print(rate_matrix)
}
}
# set rowsums to 0
for(i in 1:nrow(rate_matrix)) {
rate_matrix[i,i] <- -sum(rate_matrix[i,])
}
return(rate_matrix)
}
constructRateMatrix(2, alpha, beta, lambda_i, mu_i, lambda_a, mu_a, denovo_i = denovo_i, denovo_a = denovo_a)
constructRateMatrix <- function(num_genes,
alpha, beta,
lambda_i, mu_i,
lambda_a, mu_a,
lambda_ai = 0, lambda_ia = 0,
denovo_i = 0, denovo_a = 0, recover_x = FALSE) {
# get the number of states
num_states <- computeNumStates(num_genes)
# get the state labels
state_labels <- getStateLabels(num_genes)
# make a blank matrix
rate_matrix <- matrix(0, num_states, num_states, dimnames=list(state_labels,state_labels))
# fill in the denovo origination rates
rate_matrix[1,3] <- denovo_i
rate_matrix[1,4] <- denovo_a
# now fill in the rest of the matrix
for(fam_size in 1:num_genes) {
for(num_active in 1:fam_size) {
if(recover_x) recover()
i = 2 + 0.5 * fam_size * (fam_size + 1) + num_active
#duplication rate of inactive genes
if ( i + fam_size + 2 < num_states ) {
rate_matrix[i,i+fam_size+2] = num_active * lambda_ai + (fam_size - num_active) * lambda_i
} else {
rate_matrix[i,num_states+1] = num_active * lambda_ai + (fam_size - num_active) * lambda_i
}
#duplication rate of active genes
if ( i + fam_size + 3 <= num_states ) {
rate_matrix[i,i+fam_size+3] = (fam_size - num_active) * lambda_ia + num_active * lambda_a
} else {
rate_matrix[i,num_states+1] = rate_matrix[i,num_states] + (fam_size - num_active) * lambda_ia + num_active * lambda_a
}
#deletion and inactivation rates of active genes
if ( num_active > 0 ) {
rate_matrix[i,i-fam_size] = mu_a * num_active;
rate_matrix[i,i] = beta * num_active;
}
#deletion and activation rates of inactive genes
if ( fam_size > num_active ) {
rate_matrix[i,i-fam_size+1] = mu_i * (fam_size - num_active);
rate_matrix[i,i+2] = alpha * (fam_size - num_active);
}
print(rate_matrix)
}
}
# set rowsums to 0
for(i in 1:nrow(rate_matrix)) {
rate_matrix[i,i] <- -sum(rate_matrix[i,])
}
return(rate_matrix)
}
constructRateMatrix(2, alpha, beta, lambda_i, mu_i, lambda_a, mu_a, denovo_i = denovo_i, denovo_a = denovo_a)
0.5 * (8+2)*(8+1)
3 + 0.5 * 8 * (8+1) + 8
getStateLabels(8)
3 + 8 * (8 + 1)
3 + 0.5 * 8 * (8 + 1)
2 + 0.5 * (8 + 2) * (8 + 1)
#' computes the number of states (dimensions of the rate matrix) from the number of genes
#' @param num_genes the maximum number of genes in gene families allowed
#' @return the number of states (dimensions of the rate matrix)
computeNumStates <- function(num_genes) {
2 + 0.5 * (num_genes + 1) * (num_genes + 2) #add 2 for < P E > and < Inf > states
}
#' constructs the vector of state names for the given number of genes
#' @param num_genes the maximum number of genes in gene families allowed
#' @return the names of each possible state, including the 0 and absorbing state
getStateLabels <- function(num_genes) {
num_states <- computeNumStates(num_genes)
state_labels <- character(num_states)
state_labels[1:2] <- c("<PE>", "<0,0>")
state_labels[num_states] <- paste0("<Inf>")
k <- 3
for(i in 1:num_genes) {
for(j in 0:i) {
state_labels[k] <- paste0("<",i,",",j,">")
k <- k + 1
}
}
return(state_labels)
}
constructRateMatrix <- function(num_genes,
alpha, beta,
lambda_i, mu_i,
lambda_a, mu_a,
lambda_ai = 0, lambda_ia = 0,
denovo_i = 0, denovo_a = 0, recover_x = FALSE) {
# get the number of states
num_states <- computeNumStates(num_genes)
# get the state labels
state_labels <- getStateLabels(num_genes)
# make a blank matrix
rate_matrix <- matrix(0, num_states, num_states, dimnames=list(state_labels,state_labels))
# fill in the denovo origination rates
rate_matrix[1,3] <- denovo_i
rate_matrix[1,4] <- denovo_a
# now fill in the rest of the matrix
for(fam_size in 1:num_genes) {
for(num_active in 0:fam_size) {
if(recover_x) recover()
i = 2 + 0.5 * fam_size * (fam_size + 1) + num_active
#duplication rate of inactive genes
if ( i + fam_size + 2 < num_states ) {
rate_matrix[i,i+fam_size+1] = num_active * lambda_ai + (fam_size - num_active) * lambda_i
} else {
rate_matrix[i,num_states] = num_active * lambda_ai + (fam_size - num_active) * lambda_i
}
#duplication rate of active genes
if ( i + fam_size + 3 <= num_states ) {
rate_matrix[i,i+fam_size+2] = (fam_size - num_active) * lambda_ia + num_active * lambda_a
} else {
rate_matrix[i,num_states] = rate_matrix[i,num_states] + (fam_size - num_active) * lambda_ia + num_active * lambda_a
}
#deletion and inactivation rates of active genes
if ( num_active > 0 ) {
rate_matrix[i,i-fam_size-1] = mu_a * num_active;
rate_matrix[i,i-1] = beta * num_active;
}
#deletion and activation rates of inactive genes
if ( fam_size > num_active ) {
rate_matrix[i,i-fam_size] = mu_i * (fam_size - num_active);
rate_matrix[i,i+1] = alpha * (fam_size - num_active);
}
print(rate_matrix)
}
}
# set rowsums to 0
for(i in 1:nrow(rate_matrix)) {
rate_matrix[i,i] <- -sum(rate_matrix[i,])
}
return(rate_matrix)
}
constructRateMatrix(2, alpha, beta, lambda_i, mu_i, lambda_a, mu_a, denovo_i = denovo_i, denovo_a = denovo_a)
denovo_i = 0.01
denovo_a = 0.01
alpha = 1.2
beta = 1.1
lambda_a = 1.2
lambda_i = 1.1
mu_a = 0.9
mu_i = 0.8
m = 100
#' computes the number of states (dimensions of the rate matrix) from the number of genes
#' @param num_genes the maximum number of genes in gene families allowed
#' @return the number of states (dimensions of the rate matrix)
computeNumStates <- function(num_genes) {
2 + 0.5 * (num_genes + 1) * (num_genes + 2) #add 2 for < P E > and < Inf > states
}
#' constructs the vector of state names for the given number of genes
#' @param num_genes the maximum number of genes in gene families allowed
#' @return the names of each possible state, including the 0 and absorbing state
getStateLabels <- function(num_genes) {
num_states <- computeNumStates(num_genes)
state_labels <- character(num_states)
state_labels[1:2] <- c("<PE>", "<0,0>")
state_labels[num_states] <- paste0("<Inf>")
k <- 3
for(i in 1:num_genes) {
for(j in 0:i) {
state_labels[k] <- paste0("<",i,",",j,">")
k <- k + 1
}
}
return(state_labels)
}
constructRateMatrix <- function(num_genes,
alpha, beta,
lambda_i, mu_i,
lambda_a, mu_a,
lambda_ai = 0, lambda_ia = 0,
denovo_i = 0, denovo_a = 0, recover_x = FALSE) {
# get the number of states
num_states <- computeNumStates(num_genes)
# get the state labels
state_labels <- getStateLabels(num_genes)
# make a blank matrix
rate_matrix <- matrix(0, num_states, num_states, dimnames=list(state_labels,state_labels))
# fill in the denovo origination rates
rate_matrix[1,3] <- denovo_i
rate_matrix[1,4] <- denovo_a
# now fill in the rest of the matrix
for(fam_size in 1:num_genes) {
for(num_active in 0:fam_size) {
if(recover_x) recover()
i = 2 + 0.5 * fam_size * (fam_size + 1) + num_active
#duplication rate of inactive genes
if ( i + fam_size + 2 < num_states ) {
rate_matrix[i,i+fam_size+1] = num_active * lambda_ai + (fam_size - num_active) * lambda_i
} else {
rate_matrix[i,num_states] = num_active * lambda_ai + (fam_size - num_active) * lambda_i
}
#duplication rate of active genes
if ( i + fam_size + 3 <= num_states ) {
rate_matrix[i,i+fam_size+2] = (fam_size - num_active) * lambda_ia + num_active * lambda_a
} else {
rate_matrix[i,num_states] = rate_matrix[i,num_states] + (fam_size - num_active) * lambda_ia + num_active * lambda_a
}
#deletion and inactivation rates of active genes
if ( num_active > 0 ) {
rate_matrix[i,i-fam_size-1] = mu_a * num_active;
rate_matrix[i,i-1] = beta * num_active;
}
#deletion and activation rates of inactive genes
if ( fam_size > num_active ) {
rate_matrix[i,i-fam_size] = mu_i * (fam_size - num_active);
rate_matrix[i,i+1] = alpha * (fam_size - num_active);
}
print(rate_matrix)
}
}
# set rowsums to 0
for(i in 1:nrow(rate_matrix)) {
rate_matrix[i,i] <- -sum(rate_matrix[i,])
}
return(rate_matrix)
}
constructRateMatrix(2, alpha, beta, lambda_i, mu_i, lambda_a, mu_a, denovo_i = denovo_i, denovo_a = denovo_a)
constructRateMatrix(4, alpha, beta, lambda_i, mu_i, lambda_a, mu_a, denovo_i = denovo_i, denovo_a = denovo_a)
constructRateMatrix <- function(num_genes,
alpha, beta,
lambda_i, mu_i,
lambda_a, mu_a,
lambda_ai = 0, lambda_ia = 0,
denovo_i = 0, denovo_a = 0, recover_x = FALSE) {
# get the number of states
num_states <- computeNumStates(num_genes)
# get the state labels
state_labels <- getStateLabels(num_genes)
# make a blank matrix
rate_matrix <- matrix(0, num_states, num_states, dimnames=list(state_labels,state_labels))
# fill in the denovo origination rates
rate_matrix[1,3] <- denovo_i
rate_matrix[1,4] <- denovo_a
# now fill in the rest of the matrix
for(fam_size in 1:num_genes) {
for(num_active in 0:fam_size) {
if(recover_x) recover()
i = 2 + 0.5 * fam_size * (fam_size + 1) + num_active
#duplication rate of inactive genes
if ( i + fam_size + 2 < num_states ) {
rate_matrix[i,i+fam_size+1] = num_active * lambda_ai + (fam_size - num_active) * lambda_i
} else {
rate_matrix[i,num_states] = num_active * lambda_ai + (fam_size - num_active) * lambda_i
}
#duplication rate of active genes
if ( i + fam_size + 3 <= num_states ) {
rate_matrix[i,i+fam_size+2] = (fam_size - num_active) * lambda_ia + num_active * lambda_a
} else {
rate_matrix[i,num_states] = rate_matrix[i,num_states] + (fam_size - num_active) * lambda_ia + num_active * lambda_a
}
#deletion and inactivation rates of active genes
if ( num_active > 0 ) {
rate_matrix[i,i-fam_size-1] = mu_a * num_active;
rate_matrix[i,i-1] = beta * num_active;
}
#deletion and activation rates of inactive genes
if ( fam_size > num_active ) {
rate_matrix[i,i-fam_size] = mu_i * (fam_size - num_active);
rate_matrix[i,i+1] = alpha * (fam_size - num_active);
}
}
}
# set rowsums to 0
for(i in 1:nrow(rate_matrix)) {
rate_matrix[i,i] <- -sum(rate_matrix[i,])
}
return(rate_matrix)
}
constructRateMatrix(4, alpha, beta, lambda_i, mu_i, lambda_a, mu_a, denovo_i = denovo_i, denovo_a = denovo_a) -> M
M
eigen(M)
plot(eigen(M)$values)
library(compDriftUtils)
omega = 2
sigma_m = 2
N = 50
mu = 10^-2
sigmaD2 = 1.543 * (mu * omega^3)/(sigma_m * N^(3/2))
# other params ####
theta = 4
Dstar = theta
D0 = 2
p1 = (D0 + theta)/2
p2 = (theta - D0)/2
total_time = 10^4
sample_rate = 10000
time_trace = vector(mode="numeric", length = (total_time - (total_time%%sample_rate))/sample_rate)
p1_trace = vector(mode="numeric", length = (total_time - (total_time%%sample_rate))/sample_rate)
p2_trace = vector(mode="numeric", length = (total_time - (total_time%%sample_rate))/sample_rate)
p1_trace[1] = c(p1)
p2_trace[1] = c(p2)
time_trace[1] = 0
index = 2
num_mutations = 0
#Discrete
num_sims = 100
sim_results =c()
for(i in seq(num_sims)) sim_results =
c(sim_results, run_stochastic_sim(5,5, theta, total_time, mu, N, sigma_m, omega))
hist(sim_res)
hist(sim_results)
hist(sim_results, breaks = 20)
?run_stochastic_sim
?run_stochastic_sim
?rD_sample
?random_D
??random_D
?compdDriftUtils
library(devtools)
build("compDriftUtils")
library()
library(compDriftUtils)
?run_stochastic_sim
library(compDriftUtils)
random_D
?random_D
random_D()
library(compDriftUtils)
random_D
random_D()
compDriftUtils::random_D()
?random_D
.libPaths()
remove.packages("compDriftUtils")
install.packages("compDriftUtils")
install.packages("compDriftUtils")
library(compDriftUtils)
random_D()
library(compDriftUtils)
random_D()
maxFinder
compDriftUtils::random_D()
library("compDriftUtils", lib.loc="~/R/win-library/3.4")
detach("package:compDriftUtils", unload=TRUE)
remove.packages(compDriftUtils)
remove.packages("compDriftUtils")
getwd()
setwd("../Desktop/git_repos/compensatory_drift/compensatory_drift/R_version/")
install.packages("compDriftUtils", type = "source", repos=NULL)
library(compDriftUtils)
random_D()
?random_D
library(compDriftUtils)
?random_D
library(compDriftUtils)
?random_D
install.packages("compDriftUtils", type = "source", repos=NULL)
?random_D
library(compDriftUtils)
?random_D
